<!-- build time:Thu Nov 21 2024 15:09:21 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="但行好事，莫问前程" href="https://60saint.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="但行好事，莫问前程" href="https://60saint.github.io/atom.xml"><link rel="alternate" type="application/json" title="但行好事，莫问前程" href="https://60saint.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="C++"><link rel="canonical" href="https://60saint.github.io/cpp/%E4%BA%8C.%E5%AE%9E%E6%88%98-%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><title>二.实战-职工管理系统 - C++ | Zn1's Blog = 但行好事，莫问前程</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">二.实战-职工管理系统</h1><div class="meta"><span class="item" title="Created: 2024-11-06 20:14:43"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2024-11-06T20:14:43+08:00">2024-11-06</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>22k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>20 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Zn1's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/assets/cpp.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cpp/" itemprop="item" rel="index" title="In C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="https://60saint.github.io/cpp/%E4%BA%8C.%E5%AE%9E%E6%88%98-%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Li Xinyi"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="但行好事，莫问前程"></span><div class="body md" itemprop="articleBody"><h1 id="1-管理系统需求"><a class="anchor" href="#1-管理系统需求">#</a> 1、管理系统需求</h1><p>职工管理系统可以用来管理公司内所有员工的信息</p><p>本教程主要利用 C++ 来实现一个基于多态的职工管理系统</p><p>公司中职工分为三类：普通员工、经理、老板，显示信息时，需要显示职工编号、职工姓名、职工岗位、以及职责</p><ul><li><p>普通员工职责：完成经理交给的任务</p></li><li><p>经理职责：完成老板交给的任务，并下发任务给员工</p></li><li><p>老板职责：管理公司所有事务</p></li></ul><p>管理系统中需要实现的功能如下：</p><ul><li>退出管理程序：退出当前管理系统</li></ul><ul><li>增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号</li><li>显示职工信息：显示公司内部所有职工的信息</li><li>删除离职职工：按照编号删除指定的职工</li><li>修改职工信息：按照编号修改职工个人信息</li><li>查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息</li><li>按照编号排序：按照职工编号，进行排序，排序规则由用户指定</li><li>清空所有文档：清空文件中记录的所有职工信息 （清空前需要再次确认，防止误删）</li></ul><p>系统界面效果图如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411071350896.png" alt=""></p><p>需根据用户不同的选择，完成不同的功能！</p><h1 id="2-创建项目"><a class="anchor" href="#2-创建项目">#</a> 2、创建项目</h1><p>打开命令面板，输入 create C++ project，按回车后可以选择保存工程的文件夹</p><h1 id="3-创建管理类"><a class="anchor" href="#3-创建管理类">#</a> 3、创建管理类</h1><p>管理类负责的内容如下：</p><ul><li><p>与用户的沟通菜单界面</p><blockquote><p>给用户提供一个菜单界面，让用户选择不同的功能，比如增加 / 修改 / 删除职工等等</p></blockquote></li><li><p>对职工增删改查的操作</p><blockquote><p>当用户选完之后，对应的功能就要做实现，实现方面也要通过这个类提供对应的成员函数。比如选择了添加职工，就要实现添加职工的功能，所以对职工的增删改查操作也是由这个类写的</p></blockquote></li><li><p>与文件的读写交互</p><blockquote><p>比如增加 / 修改完这个职工，要同步到文件中，由这个管理类提供接口来实现。包括再次打开这个项目，要从文件中读取数据，这时候也由管理类实现</p></blockquote></li></ul><h2 id="31-创建文件"><a class="anchor" href="#31-创建文件">#</a> 3.1 创建文件</h2><p>在头文件和源文件的文件夹下分别创建 workerManager.h 和 workerManager.cpp 文件</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411071433534.png" alt=""></p><h2 id="32-头文件实现"><a class="anchor" href="#32-头文件实现">#</a> 3.2 头文件实现</h2><p>在 workerManager.h 中设计管理类</p><p>代码如下：</p><pre><code class="language-C++">#pragma once          // 防止头文件重复包含
#include &lt;iostream&gt;   // 包含输入输出流头文件
using namespace std;  // 使用标准命名空间

class WorkerManager &#123;
 public:
  WorkerManager();
  ~WorkerManager();
&#125;;
</code></pre><h2 id="33-源文件实现"><a class="anchor" href="#33-源文件实现">#</a> 3.3 源文件实现</h2><p>在 workerManager.cpp 中将构造和析构函数空实现补全</p><pre><code class="language-C++">#include &quot;workerManager.h&quot;

WorkerManager::WorkerManager() &#123;
&#125;
WorkerManager::~WorkerManager() &#123;
&#125;
</code></pre><p>至此职工管理类以创建完毕</p><h1 id="4-菜单功能"><a class="anchor" href="#4-菜单功能">#</a> 4、菜单功能</h1><p>功能描述：与用户的沟通界面</p><h2 id="41-添加成员函数"><a class="anchor" href="#41-添加成员函数">#</a> 4.1 添加成员函数</h2><p>在管理类 workerManager.h 中添加成员函数 <code>void Show_Menu();</code></p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411071457606.png" alt=""></p><h2 id="42-菜单功能实现"><a class="anchor" href="#42-菜单功能实现">#</a> 4.2 菜单功能实现</h2><p>在管理类 workerManager.cpp 中实现 Show_Menu () 函数</p><pre><code class="language-C++">void WorkerManager::showMenu() &#123;
  cout &lt;&lt; &quot;********************************************&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;*********  欢迎使用职工管理系统！ **********&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;*************  0.退出管理程序  *************&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;*************  1.增加职工信息  *************&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;*************  2.显示职工信息  *************&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;*************  3.删除离职职工  *************&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;*************  4.修改职工信息  *************&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;*************  5.查找职工信息  *************&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;*************  6.按照编号排序  *************&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;*************  7.清空所有文档  *************&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;********************************************&quot; &lt;&lt; endl;
  cout &lt;&lt; endl;
&#125;
</code></pre><h2 id="43-测试菜单功能"><a class="anchor" href="#43-测试菜单功能">#</a> 4.3 测试菜单功能</h2><p>main.cpp 中测试菜单功能</p><p>代码：</p><pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
#include &quot;workerManager.h&quot;

int main() &#123;
  // 实例化管理者对象
  WorkerManager wm;
  // 调用展示菜单成员函数
  wm.showMenu();

  system(&quot;read -n 1 -s -p 'Press any key to continue...'&quot;);
  return 0;
&#125;

</code></pre><p>运行效果如图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411071459011.png" alt=""></p><h1 id="5-退出功能"><a class="anchor" href="#5-退出功能">#</a> 5、退出功能</h1><h2 id="51-提供功能接口"><a class="anchor" href="#51-提供功能接口">#</a> 5.1 提供功能接口</h2><p>在 main 函数中提供分支选择，提供每个功能接口</p><p>代码：</p><pre><code class="language-C++">int main() &#123;
  WorkerManager wm;

  int choice = 0;  // 用来存储用户的选项
  while (true) &#123;
    wm.showMenu();
    cout &lt;&lt; &quot;请输入您的选择：&quot; &lt;&lt; endl;
    cin &gt;&gt; choice;  // 接受用户的选项
    switch (choice) &#123;
      case 0:  // 退出系统
        break;
      case 1:  // 增加职工
        break;
      case 2:  // 显示职工
        break;
      case 3:  // 删除职工
        break;
      case 4:  // 修改职工
        break;
      case 5:  // 查找职工
        break;
      case 6:  // 排序职工
        break;
      case 7:  // 清空文档
        break;
      default:
        system(&quot;clear&quot;);  // 清屏
        break;
    &#125;
  &#125;

  system(&quot;read -n 1 -s -p 'Press any key to continue...'&quot;);
  return 0;
&#125;
</code></pre><h2 id="52-实现退出功能"><a class="anchor" href="#52-实现退出功能">#</a> 5.2 实现退出功能</h2><p>在 workerManager.h 中提供退出系统的成员函数 <code>void exitSystem();</code></p><p>在 workerManager.cpp 中提供具体的功能实现</p><pre><code class="language-C++">void WorkerManager::exitSystem() &#123;
  cout &lt;&lt; &quot;欢迎下次使用&quot; &lt;&lt; endl;
  system(&quot;read -n 1 -s -p 'Press any key to continue...'&quot;);
  exit(0);  // 退出程序
&#125;
</code></pre><h2 id="53-测试功能"><a class="anchor" href="#53-测试功能">#</a> 5.3 测试功能</h2><p>在 main 函数分支 0 选项中，调用退出程序的接口</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>  <span class="token comment">// 退出系统</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  wm<span class="token punctuation">.</span><span class="token function">exitSystem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>运行测试效果如图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411071518218.png" alt=""></p><h1 id="6-创建职工类"><a class="anchor" href="#6-创建职工类">#</a> 6、创建职工类</h1><h2 id="61-创建职工抽象类"><a class="anchor" href="#61-创建职工抽象类">#</a> 6.1 创建职工抽象类</h2><p>职工的分类为：普通员工、经理、老板</p><p>将三种职工抽象到一个类（worker）中，利用多态管理不同职工种类</p><p>职工的属性为：职工编号、职工姓名、职工所在部门编号</p><p>职工的行为为：岗位职责信息描述，获取岗位名称</p><p>头文件文件夹下 创建文件 worker.h 文件并且添加如下代码：</p><pre><code class="language-C++">#pragma once
#include &lt;iostream&gt;
using namespace std;
#include &lt;string&gt;

// 职工抽象类
class Worker &#123;
 public:
  int m_Id;       // 职工编号
  string m_Name;  // 职工姓名
  int m_DeptId;   // 部门编号

  // 显示个人信息
  virtual void showInfo() = 0;  // 在抽象类中不做任何函数的实现，所以写成纯虚函数
  // 获取岗位名称
  virtual void getDeptName() = 0;
&#125;;
</code></pre><blockquote><p>Worker 这个抽象类不需要实现，所以不用创建.cpp 源文件</p></blockquote><h2 id="62-创建普通员工类"><a class="anchor" href="#62-创建普通员工类">#</a> 6.2 创建普通员工类</h2><p>普通员工类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数</p><p>在头文件和源文件的文件夹下分别创建 employee.h 和 employee.cpp 文件</p><p>employee.h 中代码如下：</p><pre><code class="language-C++">// 普通员工文件
#pragma once
#include &lt;iostream&gt;
using namespace std;
#include &quot;worker.h&quot;

class Employee : public Worker &#123;
 public:
  Employee(int id, string name, int dId);  // 提供一个构造函数，因为每一个员工在构造的时候应该初始化身上的属性

  // 显示个人信息
  virtual void showInfo();
  // 获取岗位名称
  virtual string getDeptName();
&#125;;
</code></pre><p>employee.cpp 中代码如下：</p><pre><code class="language-C++">#include &quot;employee.h&quot;

Employee::Employee(int id, string name, int dId) &#123;
  this-&gt;m_Id = id;
  this-&gt;m_Name = name;
  this-&gt;m_DeptId = dId;
&#125;

// 显示个人信息
void Employee::showInfo() &#123;
  cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;m_Id &lt;&lt; &quot;\t职工姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;\t岗位：&quot; &lt;&lt; this-&gt;getDeptName() &lt;&lt; &quot;\t岗位职责：完成经理交给的任务&quot; &lt;&lt; endl;
&#125;
// 获取岗位名称
string Employee::getDeptName() &#123;
  return string(&quot;员工&quot;);  // 直接返回&quot;员工&quot;的话是const char*类型。用不用string包含都可以，因为如果不包含的话编译器会做隐式类型转换，把const char*转成string
&#125;
</code></pre><blockquote><ul><li>字面量 <code>&quot;员工&quot;</code> 在 C++ 中被视为 <code>const char[]</code> 类型，实际上是一个指向该数组首元素的指针，即 <code>const char*</code> 。</li><li>当将这个字面量传递给 <code>std::string</code> 的构造函数时，它会将这个 <code>const char*</code> 转换为 <code>std::string</code> 对象。</li><li><code>std::string</code> 是 C++ 标准库提供的一个类，用于更方便地处理字符串。它提供了许多成员函数来操作字符串，比如拼接、查找、替换等。</li></ul></blockquote><h2 id="63-创建经理类"><a class="anchor" href="#63-创建经理类">#</a> 6.3 创建经理类</h2><p>经理类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数，和普通员工类似</p><p>在头文件和源文件的文件夹下分别创建 manager.h 和 manager.cpp 文件</p><p>manager.h 中代码如下：</p><pre><code class="language-c++">#pragma once
#include &lt;iostream&gt;
using namespace std;
#include &quot;worker.h&quot;

// 经理类
class Manager : public Worker &#123;
 public:
  Manager(int id, string name, int dId);

  // 显示个人信息
  virtual void showInfo();
  // 获取岗位名称
  virtual string getDeptName();
&#125;;
</code></pre><p>manager.cpp 中代码如下：</p><pre><code class="language-c++">#include &quot;manager.h&quot;

Manager::Manager(int id, string name, int dId) &#123;
  this-&gt;m_Id = id;
  this-&gt;m_Name = name;
  this-&gt;m_DeptId = dId;
&#125;

// 显示个人信息
void Manager::showInfo() &#123;
  cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;m_Id &lt;&lt; &quot;\t职工姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;\t岗位：&quot; &lt;&lt; this-&gt;getDeptName() &lt;&lt; &quot;\t岗位职责：完成老板交给的任务，并下发任务给普通员工&quot; &lt;&lt; endl;
&#125;
// 获取岗位名称
string Manager::getDeptName() &#123;
  return string(&quot;经理&quot;);
&#125;
</code></pre><h2 id="64-创建老板类"><a class="anchor" href="#64-创建老板类">#</a> 6.4 创建老板类</h2><p>老板类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数，和普通员工类似</p><p>在头文件和源文件的文件夹下分别创建 boss.h 和 boss.cpp 文件</p><p>boss.h 中代码如下：</p><pre><code class="language-c++">#pragma once
#include &lt;iostream&gt;
using namespace std;
#include &quot;worker.h&quot;

// 老板类
class Boss : public Worker &#123;
 public:
  Boss(int id, string name, int dId);

  // 显示个人信息
  virtual void showInfo();
  // 获取岗位名称
  virtual string getDeptName();
&#125;;
</code></pre><p>boss.cpp 中代码如下：</p><pre><code class="language-c++">#include &quot;boss.h&quot;

Boss::Boss(int id, string name, int dId) &#123;
  this-&gt;m_Id = id;
  this-&gt;m_Name = name;
  this-&gt;m_DeptId = dId;
&#125;

// 显示个人信息
void Boss::showInfo() &#123;
  cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;m_Id &lt;&lt; &quot;\t职工姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;\t岗位：&quot; &lt;&lt; this-&gt;getDeptName() &lt;&lt; &quot;\t岗位职责：管理公司所有事务&quot; &lt;&lt; endl;
&#125;
// 获取岗位名称
string Boss::getDeptName() &#123;
  return string(&quot;总裁&quot;);
&#125;
</code></pre><h2 id="65-测试多态"><a class="anchor" href="#65-测试多态">#</a> 6.5 测试多态</h2><p>Main.cpp 中添加测试函数，并且运行能够产生多态</p><p>测试代码如下：</p><pre><code class="language-C++">#include &quot;boss.h&quot;
#include &quot;employee.h&quot;
#include &quot;manager.h&quot;
#include &quot;worker.h&quot;

int main() &#123;
  // 测试代码：
  Worker* worker = NULL;
  worker = new Employee(1, &quot;张三&quot;, 1);
  worker-&gt;showInfo();
  //   delete worker;

  Worker* worker2 = NULL;
  worker2 = new Manager(2, &quot;李四&quot;, 2);
  worker2-&gt;showInfo();
  //   delete worker2;

  Worker* worker3 = NULL;
  worker3 = new Boss(3, &quot;王五&quot;, 3);
  worker3-&gt;showInfo();
  //   delete worker3;
&#125;
</code></pre><blockquote><p>先不 delete，因为 Worker 类没有虚析构函数，所以通过基类指针删除派生类对象时，不会走子类 Employee / Manager / Boss 的析构函数，只会调用基类的析构函数。可能会导致派生类中分配的资源（如动态分配的内存）无法被正确释放，从而引发内存泄漏</p></blockquote><p>运行效果如图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411071650618.png" alt=""></p><blockquote><p>多态主要体现在 showInfo，一个函数有多种形态。当 3 个不同的对象都调用 showInfo 的时候，显示的内容是不一样的，因为不同子类里边具体的代码实现是不一样的</p></blockquote><p>测试成功后，测试代码可以注释保留，或者选择删除</p><h1 id="7-添加职工"><a class="anchor" href="#7-添加职工">#</a> 7、添加职工</h1><p>功能描述：批量添加职工，并且保存到文件中</p><h2 id="71-功能分析"><a class="anchor" href="#71-功能分析">#</a> 7.1 功能分析</h2><p>分析：</p><p>用户在批量创建时，可能会创建不同种类的职工</p><blockquote><p>比如添加了 5 个职工，怎么记录这 5 个职工呢？可以通过一个数组记录这 5 个职工。这个时候有一个问题，职工有不同的种类，可能有的职工是普通员工 Employee 类的对象，还有可能是经理 Manager 类的对象，还有可能是老板 Boss 的对象。每个对象不一样，又知道数组中要存放相同类型的数据，所以问题就是怎么通过一个数组把所有的职工放进去</p></blockquote><p>如果想将所有不同种类的员工都放入到一个数组中，可以将所有员工的指针维护到一个数组里</p><p>如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用 Worker** 的指针维护</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411072141029.jpg" alt=""></p><blockquote><p><code>Worker** = new Worker*[5]</code> 。new 一个每个元素都是 Worker * 的数组，一共有五个元素，它的返回值等号左侧应该写 <code>Worker**</code> 去接收它</p><p>父类的指针一开始创建 5 个，如果再添加职工，可以把 5 个再扩展。可以再找一个更长的内存，加到 6 个或 7 个元素，把原来的数据加进来，把原来空间释放掉</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411072149409.png" alt=""></p></blockquote><h2 id="72-功能实现"><a class="anchor" href="#72-功能实现">#</a> 7.2 功能实现</h2><p>在 WokerManager.h 头文件中添加成员属性 代码：</p><pre><code class="language-C++">int m_EmpNum;         // 记录职工人数
Worker** m_EmpArray;  // 职工数组指针。数组的每个元素是指向Worker类对象的指针，那么该数组的首地址就是Worker**
</code></pre><p>在 WorkerManager 构造函数中初始化属性</p><pre><code class="language-C++">WorkerManager::WorkerManager() &#123;
  // 初始化属性
  this-&gt;m_EmpNum = 0;
  this-&gt;m_EmpArray = NULL;
&#125;
</code></pre><p>在 workerManager.h 中添加成员函数</p><pre><code class="language-C++">// 添加职工
void addEmp();
</code></pre><p>workerManager.cpp 中实现该函数</p><pre><code class="language-C++">// 添加职工
void WorkerManager::addEmp() &#123;
  cout &lt;&lt; &quot;请输入添加职工数量：&quot; &lt;&lt; endl;
  int addNum = 0;  // 保存用户的输入数量
  cin &gt;&gt; addNum;
  if (addNum &gt; 0) &#123;  // 添加
    // 计算添加新空间大小
    int newSize = this-&gt;m_EmpNum + addNum;  // 新空间人数 = 原来记录人数 + 新增人数

    // 开辟新空间
    Worker** newSpace = new Worker*[newSize];

    // 将原来空间下数据，拷贝到新空间下
    if (this-&gt;m_EmpArray != NULL) &#123;  // 如果只检查 this-&gt;m_EmpNum != 0，而 m_EmpArray 仍然是 NULL，那么在尝试访问 m_EmpArray[i] 时会导致程序崩溃
      for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) &#123;
        newSpace[i] = this-&gt;m_EmpArray[i];
      &#125;
    &#125;

    // 批量添加新数据
    for (int i = 0; i &lt; addNum; i++) &#123;
      int id;       // 职工编号
      string name;  // 职工姓名
      int dSelect;  // 部门选择
      cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;个新职工编号：&quot; &lt;&lt; endl;
      cin &gt;&gt; id;
      cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;个新职工姓名：&quot; &lt;&lt; endl;
      cin &gt;&gt; name;
      cout &lt;&lt; &quot;请选择该职工岗位：&quot; &lt;&lt; endl;
      cout &lt;&lt; &quot;1、普通职工&quot; &lt;&lt; endl;
      cout &lt;&lt; &quot;2、经理&quot; &lt;&lt; endl;
      cout &lt;&lt; &quot;3、老板&quot; &lt;&lt; endl;
      cin &gt;&gt; dSelect;

      Worker* worker = NULL;
      switch (dSelect) &#123;
        case 1:
          worker = new Employee(id, name, 1);
          break;
        case 2:
          worker = new Manager(id, name, 2);
          break;
        case 3:
          worker = new Employee(id, name, 3);
          break;
      &#125;

      // 将创建的职工指针，保存到数组中
      newSpace[this-&gt;m_EmpNum + i] = worker;
    &#125;

    // 释放原有空间
    delete[] this-&gt;m_EmpArray;  // 要释放的是一个数组，所以要加一个中括号[]

    // 更改新空间的指向
    this-&gt;m_EmpArray = newSpace;

    // 更新新的职工人数
    this-&gt;m_EmpNum = newSize;

    // 成功添加后，保存到文件中

    // 提示添加成功
    cout &lt;&lt; &quot;成功添加&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工！&quot; &lt;&lt; endl;
  &#125; else &#123;
    cout &lt;&lt; &quot;输入数据有误&quot; &lt;&lt; endl;
  &#125;

  // 按任意键后清屏回到上级目录
  system(&quot;read -n 1 -s -p 'Press any key to continue...'&quot;);
  system(&quot;clear&quot;);
&#125;
</code></pre><blockquote><p><strong><code>delete</code> vs <code>delete[]</code></strong></p><ol><li><p><strong><code>delete</code> </strong>:</p><ul><li><p>用于释放通过 <code>new</code> 分配的单个对象。</p></li><li><p>例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>  <span class="token comment">// 正确，释放单个对象</span></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>delete[]</code> </strong>:</p><ul><li><p>用于释放通过 <code>new[]</code> 分配的数组。</p></li><li><p>例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span><span class="token operator">*</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 分配一个数组</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>  <span class="token comment">// 正确，释放数组</span></pre></td></tr></table></figure></li></ul></li></ol><p><strong>区别</strong></p><p>内存管理:</p><ul><li>当你使用 <code>new[]</code> 分配一个数组时，编译器会在数组的开头存储数组的大小信息，以便在调用 <code>delete[]</code> 时能够正确地调用每个元素的析构函数（如果有的话）并释放相应的内存。</li><li>如果你使用 <code>delete</code> 来释放一个数组，编译器不会知道这是一个数组，因此它只会释放第一个元素的内存，可能导致内存泄漏或未定义行为。</li></ul></blockquote><p>workerManager.cpp 中实现析构函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">WorkerManager</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">WorkerManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">// WorkerManager 的 m_EmpArray 成员属性是开辟在堆区的数据，最好在析构函数中释放。虽然程序执行完自动释放所有分配的内存，但这并不意味着可以忽略在析构函数中释放内存。特别是在长时间运行的程序或需要频繁分配和释放内存的程序中，未能正确释放内存会导致内存泄漏，最终可能导致程序崩溃或性能下降</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>m_EmpArray <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">this</span><span class="token operator">-></span>m_EmpArray<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">this</span><span class="token operator">-></span>m_EmpArray <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="73-测试添加"><a class="anchor" href="#73-测试添加">#</a> 7.3 测试添加</h2><p>在 main 函数分支 1 选项中，调用添加职工接口</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>  <span class="token comment">// 增加职工</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  wm<span class="token punctuation">.</span><span class="token function">addEmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>至此，添加职工到程序中功能实现完毕</p><h1 id="8-文件交互-写文件"><a class="anchor" href="#8-文件交互-写文件">#</a> 8、文件交互 - 写文件</h1><p>功能描述：对文件进行读写</p><p>在上一个添加功能中，我们只是将所有的数据添加到了内存中，一旦程序结束就无法保存了</p><p>因此文件管理类中需要一个与文件进行交互的功能，对于文件进行读写操作</p><h2 id="81-设定文件路径"><a class="anchor" href="#81-设定文件路径">#</a> 8.1 设定文件路径</h2><p>首先我们将文件路径，在 workerManager.h 中添加宏常量，并且包含头文件 fstream</p><pre><code class="language-C++">#include &lt;fstream&gt;

#define  FILENAME &quot;workerFile.txt&quot;
</code></pre><h2 id="82-成员函数声明"><a class="anchor" href="#82-成员函数声明">#</a> 8.2 成员函数声明</h2><p>在 workerManager.h 中类里添加成员函数 <code>void save()</code></p><pre><code class="language-C++">//保存文件
void save();
</code></pre><h2 id="83-保存文件功能实现"><a class="anchor" href="#83-保存文件功能实现">#</a> 8.3 保存文件功能实现</h2><pre><code class="language-C++">// 保存文件
void WorkerManager::save() &#123;
  ofstream ofs;
  ofs.open(FILENAME, ios::out);  // 用输出的方式打开文件 - 写文件

  // 将每个人数据写入到文件中
  for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) &#123;
    ofs &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl;
  &#125;

  // 关闭文件
  ofs.close();
&#125;
</code></pre><h2 id="84-保存文件功能测试"><a class="anchor" href="#84-保存文件功能测试">#</a> 8.4 保存文件功能测试</h2><p>在添加职工功能中添加成功后添加保存文件函数</p><p>在 workerManager.cpp 的 addEmp 函数中结尾处插入：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 成功添加职工后，保存到文件中</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>再次运行代码，添加职工</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411081356510.png" alt=""></p><p>同级目录下多出文件，并且保存了添加的信息</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411081358645.png" alt=""></p><h1 id="9-文件交互-读文件"><a class="anchor" href="#9-文件交互-读文件">#</a> 9、文件交互 - 读文件</h1><p>功能描述：将文件中的内容读取到程序中</p><p>虽然我们实现了添加职工后保存到文件的操作，但是每次开始运行程序，并没有将文件中数据读取到程序中</p><p>而我们的程序功能中还有清空文件的需求</p><p>因此构造函数初始化数据的情况分为三种</p><ol><li><p>第一次使用，文件未创建</p></li><li><p>文件存在，但是数据被用户清空</p><blockquote><p>因为自后还要提供一个清空文件的功能，所以这个文件是存在的，只不过里边一行代码都没有，一个数据都没有</p></blockquote></li><li><p>文件存在，并且保存职工的所有数据</p></li></ol><h2 id="91-文件未创建"><a class="anchor" href="#91-文件未创建">#</a> 9.1 文件未创建</h2><p>在 workerManager.h 中添加新的成员属性 m_FileIsEmpty 标志文件是否为空</p><pre><code class="language-C++">//标志文件是否为空
bool m_FileIsEmpty;
</code></pre><p>修改 WorkerManager.cpp 中构造函数代码</p><pre><code class="language-C++">WorkerManager::WorkerManager() &#123;
  // 1、文件不存在
  ifstream ifs;
  ifs.open(FILENAME, ios::in);  // 读文件
  if (!ifs.is_open()) &#123;
    cout &lt;&lt; &quot;文件不存在&quot; &lt;&lt; endl;
    // 初始化属性
    this-&gt;m_EmpNum = 0;          // 初始化记录人数
    this-&gt;m_EmpArray = NULL;     // 初始化数组指针
    this-&gt;m_FileIsEmpty = true;  // 初始化文件是否为空
    ifs.close();
    return;
  &#125;
&#125;
</code></pre><p>删除文件后，测试文件不存在时初始化数据功能</p><h2 id="92-文件存在且数据为空"><a class="anchor" href="#92-文件存在且数据为空">#</a> 9.2 文件存在且数据为空</h2><p>在 workerManager.cpp 中的构造函数追加代码：</p><pre><code class="language-C++">// 2、文件存在但数据为空
char ch;
ifs &gt;&gt; ch;
if (ifs.eof()) &#123;
  // 文件为空
  cout &lt;&lt; &quot;文件为空&quot; &lt;&lt; endl;
  this-&gt;m_EmpNum = 0;
  this-&gt;m_EmpArray = NULL;
  this-&gt;m_FileIsEmpty = true;
  ifs.close();
  return;
&#125;
</code></pre><blockquote><p><code>ifs &gt;&gt; ch;</code> 用于从文件流中读取一个字符，并且通过 <code>ifs.eof()</code> 判断是否已经到达文件的末尾（EOF）。如果文件为空，则 <code>ifs &gt;&gt; ch;</code> 会立即遇到 EOF，条件 <code>ifs.eof()</code> 为真</p></blockquote><p>将文件创建后清空文件内容，并测试该情况下初始化功能</p><p>我们发现文件不存在或者为空清空 m_FileIsEmpty 判断文件是否为空的标志都为真，那何时为假？</p><p>成功添加职工后，应该更改文件不为空的标志</p><p>在 <code>void WorkerManager::Add_Emp()</code> 成员函数中添加：</p><pre><code class="language-C++">//更新职工不为空标志
this-&gt;m_FileIsEmpty = false;
</code></pre><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411081419730.png" alt=""></p><h2 id="93-文件存在且保存职工数据"><a class="anchor" href="#93-文件存在且保存职工数据">#</a> 9.3 文件存在且保存职工数据</h2><h3 id="931-获取记录的职工人数"><a class="anchor" href="#931-获取记录的职工人数">#</a> 9.3.1 获取记录的职工人数</h3><p>在 workerManager.h 中添加成员函数 <code>int get_EmpNum();</code></p><pre><code class="language-C++">// 统计文件中人数
int getEmpNum();
</code></pre><p>workerManager.cpp 中实现</p><pre><code class="language-C++">// 统计文件中人数
int WorkerManager::getEmpNum() &#123;
  ifstream ifs;
  ifs.open(FILENAME, ios::in);  // 打开文件，读

  int id;
  string name;
  int dId;

  int num = 0;
  while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId) &#123;
    num++;  // 统计人数变量
  &#125;
  return num;
&#125;
</code></pre><blockquote><p><strong><code>while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)</code> 语句的工作原理</strong></p><ol><li><strong><code>ifs &gt;&gt; id</code> </strong>：<br>这是从文件中读取一个整数并将其存储到 <code>id</code> 变量中。 <code>&gt;&gt;</code> 操作符在读取时会跳过空格、制表符和换行符，直到它遇到一个非空格字符，然后把字符转换成目标类型（在这个例子中是 <code>int</code> ）。</li><li><strong><code>ifs &gt;&gt; name</code> </strong>：<br>这是从文件中读取一个字符串并将其存储到 <code>name</code> 变量中。 <code>&gt;&gt;</code> 操作符会读取直到第一个空格、制表符或换行符为止的字符序列，并将它们作为一个字符串赋值给 <code>name</code> 。</li><li><strong><code>ifs &gt;&gt; dId</code> </strong>：<br>这又是一个整数读取操作，与 <code>ifs &gt;&gt; id</code> 类似，它从文件中读取一个整数并将其存储到 <code>dId</code> 中。</li></ol><p><strong>循环的执行</strong></p><p><code>while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)</code> 这个循环会继续执行，直到其中任意一个 <code>&gt;&gt;</code> 操作失败为止。这里的 “失败” 意味着：</p><ul><li><code>ifs &gt;&gt; id</code> ：如果遇到非数字字符，或者到达文件末尾（EOF），这个操作会失败。</li><li><code>ifs &gt;&gt; name</code> ：如果遇到非字母字符（如数字或空白字符），或者到达文件末尾（EOF），这个操作会失败。</li><li><code>ifs &gt;&gt; dId</code> ：同样，如果遇到无法转换成整数的字符，或者到达文件末尾（EOF），这个操作会失败。</li></ul><p>每一次循环的过程中， <code>while</code> 语句会尝试依次读取这三项数据。如果文件数据格式正确且符合预期，读取会成功；如果遇到文件结束或数据格式不正确（例如数据行缺失了某个字段）， <code>&gt;&gt;</code> 操作将失败，循环会终止。</p><p><strong>例子</strong></p><p>假设文件 <code>workerFile.txt</code> 内容如下：</p><figure class="highlight txt"><figcaption data-lang="txt"></figcaption><table><tr><td data-num="1"></td><td><pre>1 张三 1</pre></td></tr><tr><td data-num="2"></td><td><pre>2 李四 2</pre></td></tr><tr><td data-num="3"></td><td><pre>3 王五 3</pre></td></tr></table></figure><ol><li>第一次循环：<ul><li><code>ifs &gt;&gt; id</code> 读取 <code>1</code> （ <code>id = 1</code> ）。</li><li><code>ifs &gt;&gt; name</code> 读取 <code>张三</code> （ <code>name = &quot;张三&quot;</code> ）。</li><li><code>ifs &gt;&gt; dId</code> 读取 <code>1</code> （ <code>dId = 1</code> ）。</li><li>由于这三项数据都成功读取， <code>num++</code> 执行， <code>num</code> 增加 1。</li></ul></li><li>第二次循环：<ul><li><code>ifs &gt;&gt; id</code> 读取 <code>2</code> （ <code>id = 2</code> ）。</li><li><code>ifs &gt;&gt; name</code> 读取 <code>李四</code> （ <code>name = &quot;李四&quot;</code> ）。</li><li><code>ifs &gt;&gt; dId</code> 读取 <code>2</code> （ <code>dId = 2</code> ）。</li><li>这三项数据也成功读取， <code>num++</code> 执行， <code>num</code> 增加 1。</li></ul></li><li>第三次循环：<ul><li><code>ifs &gt;&gt; id</code> 读取 <code>3</code> （ <code>id = 3</code> ）。</li><li><code>ifs &gt;&gt; name</code> 读取 <code>王五</code> （ <code>name = &quot;王五&quot;</code> ）。</li><li><code>ifs &gt;&gt; dId</code> 读取 <code>3</code> （ <code>dId = 3</code> ）。</li><li>这三项数据都成功读取， <code>num++</code> 执行， <code>num</code> 增加 1。</li></ul></li><li>文件末尾， <code>ifs.eof()</code> 变为 <code>true</code> ，读取失败，循环结束。</li></ol></blockquote><p>在 workerManager.cpp 构造函数中继续追加代码：</p><pre><code class="language-C++">// 3、文件存在，并且记录数据
int num = this-&gt;getEmpNum();
cout &lt;&lt; &quot;职工人数为：&quot; &lt;&lt; num &lt;&lt; endl;
this-&gt;m_EmpNum = num;
</code></pre><p>手动添加一些职工数据，测试获取职工数量函数</p><p>workerFile.txt：</p><figure class="highlight txt"><figcaption data-lang="txt"></figcaption><table><tr><td data-num="1"></td><td><pre>1 张三 1</pre></td></tr><tr><td data-num="2"></td><td><pre>2 李四 2</pre></td></tr><tr><td data-num="3"></td><td><pre>3 王五 3</pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411081433838.png" alt=""></p><h3 id="932-初始化数组"><a class="anchor" href="#932-初始化数组">#</a> 9.3.2 初始化数组</h3><p>根据职工的数据以及职工数据，初始化 workerManager 中的 Worker** m_EmpArray 指针</p><p>在 WorkerManager.h 中添加成员函数 <code>void init_Emp();</code></p><pre><code class="language-C++">// 初始化职工
void initEmp();
</code></pre><p>在 WorkerManager.cpp 中实现</p><pre><code class="language-C++">// 初始化职工
void WorkerManager::initEmp() &#123;
  ifstream ifs;
  ifs.open(FILENAME, ios::in);

  int id;
  string name;
  int dId;

  int index = 0;
  while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId) &#123;
    Worker* worker = NULL;
    if (dId == 1) &#123;  // 普通职工
      worker = new Employee(id, name, dId);
    &#125; else if (dId == 2) &#123;  // 经理
      worker = new Manager(id, name, dId);
    &#125; else &#123;  // 老板
      worker = new Boss(id, name, dId);
    &#125;
    this-&gt;m_EmpArray[index] = worker;
    index++;
  &#125;

  // 关闭文件
  ifs.close();
&#125;
</code></pre><p>在 workerManager.cpp 构造函数中追加代码</p><pre><code class="language-C++">// 开辟空间
this-&gt;m_EmpArray = new Worker*[this-&gt;m_EmpNum];
// 将文件中的数据，存到数组中
this-&gt;initEmp();
// 测试代码
for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) &#123;
  cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; &quot;部门编号：&quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl;
&#125;
</code></pre><p>运行程序，测试从文件中获取的数据</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411081500371.png" alt=""></p><p>至此初始化数据功能完毕，测试代码可以注释或删除掉！</p><h1 id="10-显示职工"><a class="anchor" href="#10-显示职工">#</a> 10、显示职工</h1><p>功能描述：显示当前所有职工信息</p><h2 id="101-显示职工函数声明"><a class="anchor" href="#101-显示职工函数声明">#</a> 10.1 显示职工函数声明</h2><p>在 workerManager.h 中添加成员函数 <code>void Show_Emp();</code></p><pre><code class="language-C++">// 显示职工
void showEmp();
</code></pre><h2 id="102-显示职工函数实现"><a class="anchor" href="#102-显示职工函数实现">#</a> 10.2 显示职工函数实现</h2><p>在 workerManager.cpp 中实现成员函数 <code>void Show_Emp();</code></p><pre><code class="language-C++">// 显示职工
void WorkerManager::showEmp() &#123;
  // 判断文件是否为空
  if (this-&gt;m_FileIsEmpty) &#123;
    cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl;
  &#125; else &#123;
    for (int i = 0; i &lt; m_EmpNum; i++) &#123;
      // 利用多态调用程序接口
      this-&gt;m_EmpArray[i]-&gt;showInfo();
    &#125;
  &#125;
  // 按任意键后清屏
  system(&quot;read -n 1 -s -p 'Press any key to continue...'&quot;);
  system(&quot;clear&quot;);
&#125;
</code></pre><h2 id="103-测试显示职工"><a class="anchor" href="#103-测试显示职工">#</a> 10.3 测试显示职工</h2><p>在 main 函数分支 2 选项中，调用显示职工接口</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>  <span class="token comment">// 显示职工</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  wm<span class="token punctuation">.</span><span class="token function">showEmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>测试时分别测试 文件为空和文件不为空两种情况</p><p>测试效果：</p><p>测试 1 - 文件不存在或者为空情况</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411081511183.png" alt=""></p><p>测试 2 - 文件存在且有记录情况</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411081510549.png" alt=""></p><p>测试完毕，至此，显示所有职工信息功能实现</p><h1 id="11-删除职工"><a class="anchor" href="#11-删除职工">#</a> 11、删除职工</h1><p>功能描述：按照职工的编号进行删除职工操作</p><h2 id="111-删除职工函数声明"><a class="anchor" href="#111-删除职工函数声明">#</a> 11.1 删除职工函数声明</h2><p>在 workerManager.h 中添加成员函数 <code>void Del_Emp();</code></p><pre><code class="language-C++">// 删除职工
void delEmp();
</code></pre><h2 id="112-职工是否存在函数声明"><a class="anchor" href="#112-职工是否存在函数声明">#</a> 11.2 职工是否存在函数声明</h2><p>很多功能都需要用到根据职工是否存在来进行操作如：删除职工、修改职工、查找职工</p><p>因此添加该公告函数，以便后续调用</p><p>在 workerManager.h 中添加成员函数 <code>int IsExist(int id);</code></p><pre><code class="language-C++">// 判断职工是否存在，如果存在返回职工所在数组中的位置，不存在返回-1
int isExist(int id);
</code></pre><h2 id="113-职工是否存在函数实现"><a class="anchor" href="#113-职工是否存在函数实现">#</a> 11.3 职工是否存在函数实现</h2><p>在 workerManager.cpp 中实现成员函数 <code>int IsExist(int id);</code></p><pre><code class="language-C++">// 判断职工是否存在，如果存在返回职工所在数组中的位置，不存在返回-1
int WorkerManager::isExist(int id) &#123;
  int index = -1;
  for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) &#123;
    if (this-&gt;m_EmpArray[i]-&gt;m_Id == id) &#123;
      index = i;
      break;
    &#125;
  &#125;
  return index;
&#125;
</code></pre><h2 id="114-删除职工函数实现"><a class="anchor" href="#114-删除职工函数实现">#</a> 11.4 删除职工函数实现</h2><blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411081525132.png" alt=""></p></blockquote><p>在 workerManager.cpp 中实现成员函数 <code>void Del_Emp();</code></p><pre><code class="language-C++">// 删除职工
void WorkerManager::delEmp() &#123;
  if (this-&gt;m_FileIsEmpty) &#123;
    cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl;
  &#125; else &#123;
    // 按照职工编号删除
    cout &lt;&lt; &quot;请输入想要删除职工编号：&quot; &lt;&lt; endl;
    int id;
    cin &gt;&gt; id;

    int index = this-&gt;isExist(id);
    if (index != -1) &#123;  // 说明职工存在，并且要删除掉index位置上的职工
      // 数据前移
      for (int i = index; i &lt; this-&gt;m_EmpNum - 1; i++) &#123;
        this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[i + 1];
      &#125;
      this-&gt;m_EmpNum--;  // 更新数组中记录的人员个数
      // 同步更新到文件中
      this-&gt;save();
      cout &lt;&lt; &quot;删除成功！&quot; &lt;&lt; endl;
    &#125; else &#123;
      cout &lt;&lt; &quot;删除失败，未找到该职工&quot; &lt;&lt; endl;
    &#125;
  &#125;
  // 按任意键清屏
  system(&quot;read -n 1 -s -p 'Press any key to continue...'&quot;);
  system(&quot;clear&quot;);
&#125;
</code></pre><h2 id="115-测试删除职工"><a class="anchor" href="#115-测试删除职工">#</a> 11.5 测试删除职工</h2><p>在 main 函数分支 3 选项中，调用删除职工接口</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>  <span class="token comment">// 删除职工</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  wm<span class="token punctuation">.</span><span class="token function">delEmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>测试 1 - 删除不存在职工情况</p><p>测试 2 - 删除存在的职工情况</p><p>再次显示所有职工信息，确保已经删除</p><p>查看文件中信息，再次核实员工已被完全删除</p><p>至此，删除职工功能实现完毕！</p><h1 id="12-修改职工"><a class="anchor" href="#12-修改职工">#</a> 12、修改职工</h1><p>功能描述：能够按照职工的编号对职工信息进行修改并保存</p><h2 id="121-修改职工函数声明"><a class="anchor" href="#121-修改职工函数声明">#</a> 12.1 修改职工函数声明</h2><p>在 workerManager.h 中添加成员函数 <code>void Mod_Emp();</code></p><pre><code class="language-C++">// 修改职工
void modEmp();
</code></pre><h2 id="122-修改职工函数实现"><a class="anchor" href="#122-修改职工函数实现">#</a> 12.2 修改职工函数实现</h2><p>在 workerManager.cpp 中实现成员函数 <code>void Mod_Emp();</code></p><pre><code class="language-C++">// 修改职工
void WorkerManager::modEmp() &#123;
  if (this-&gt;m_FileIsEmpty) &#123;
    cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl;
  &#125; else &#123;
    cout &lt;&lt; &quot;请输入修改职工的编号：&quot; &lt;&lt; endl;
    int id;
    cin &gt;&gt; id;

    int ret = this-&gt;isExist(id);
    if (ret != -1) &#123;
      // 查找到编号的职工
      delete this-&gt;m_EmpArray[ret];

      int newId = 0;
      string newName = &quot;&quot;;
      int dSelect = 0;
      cout &lt;&lt; &quot;查到：&quot; &lt;&lt; id &lt;&lt; &quot;号职工，请输入新职工号：&quot; &lt;&lt; endl;
      cin &gt;&gt; newId;
      cout &lt;&lt; &quot;请输入新姓名：&quot; &lt;&lt; endl;
      cin &gt;&gt; newName;
      cout &lt;&lt; &quot;请输入岗位：&quot; &lt;&lt; endl;
      cout &lt;&lt; &quot;1、普通职工&quot; &lt;&lt; endl;
      cout &lt;&lt; &quot;2、经理&quot; &lt;&lt; endl;
      cout &lt;&lt; &quot;3、老板&quot; &lt;&lt; endl;
      cin &gt;&gt; dSelect;

      Worker* worker = NULL;
      switch (dSelect) &#123;
        case 1:
          worker = new Employee(newId, newName, dSelect);
          break;
        case 2:
          worker = new Manager(newId, newName, dSelect);
          break;
        case 3:
          worker = new Boss(newId, newName, dSelect);
          break;
        default:
          break;
      &#125;

      // 更新数据到数组中
      this-&gt;m_EmpArray[ret] = worker;
      cout &lt;&lt; &quot;修改成功！&quot; &lt;&lt; endl;

      // 保存到文件中
      this-&gt;save();
    &#125; else &#123;
      cout &lt;&lt; &quot;修改失败，查无此人&quot; &lt;&lt; endl;
    &#125;
  &#125;
  system(&quot;read -n 1 -s -p 'Press any key to continue...'&quot;);
  system(&quot;clear&quot;);
&#125;
</code></pre><h2 id="123-测试修改职工"><a class="anchor" href="#123-测试修改职工">#</a> 12.3 测试修改职工</h2><p>在 main 函数分支 4 选项中，调用修改职工接口</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>  <span class="token comment">// 修改职工</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  wm<span class="token punctuation">.</span><span class="token function">modEmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>测试 1 - 修改不存在职工情况</p><p>测试 2 - 修改存在职工情况，例如将职工 &quot;李四&quot; 改为 &quot;赵四&quot;</p><p>修改后再次查看所有职工信息，并确认修改成功</p><p>再次确认文件中信息也同步更新</p><p>至此，修改职工功能已实现！</p><h1 id="13-查找职工"><a class="anchor" href="#13-查找职工">#</a> 13、查找职工</h1><p>功能描述：提供两种查找职工方式，一种按照职工编号，一种按照职工姓名</p><h2 id="131-查找职工函数声明"><a class="anchor" href="#131-查找职工函数声明">#</a> 13.1 查找职工函数声明</h2><p>在 workerManager.h 中添加成员函数 <code>void Find_Emp();</code></p><pre><code class="language-c++">// 查找职工
void findEmp();
</code></pre><h2 id="132-查找职工函数实现"><a class="anchor" href="#132-查找职工函数实现">#</a> 13.2 查找职工函数实现</h2><p>在 workerManager.cpp 中实现成员函数 <code>void Find_Emp();</code></p><pre><code class="language-C++">// 查找职工
void WorkerManager::findEmp() &#123;
  if (this-&gt;m_FileIsEmpty) &#123;
    cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl;
  &#125; else &#123;
    cout &lt;&lt; &quot;请输入查找的方式：&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;1、按职工编号查找&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;2、按职工姓名查找&quot; &lt;&lt; endl;

    int select = 0;
    cin &gt;&gt; select;
    if (select == 1) &#123;
      // 按编号查
      int id;
      cout &lt;&lt; &quot;请输入查找的职工编号：&quot; &lt;&lt; endl;
      cin &gt;&gt; id;

      int ret = isExist(id);
      if (ret != -1) &#123;
        // 找到职工
        cout &lt;&lt; &quot;查找成功！该职工信息如下：&quot; &lt;&lt; endl;
        this-&gt;m_EmpArray[ret]-&gt;showInfo();
      &#125; else &#123;
        cout &lt;&lt; &quot;查找失败，查无此人&quot; &lt;&lt; endl;
      &#125;
    &#125; else if (select == 2) &#123;
      // 按姓名查
      string name;
      cout &lt;&lt; &quot;请输入查找的姓名：&quot; &lt;&lt; endl;
      cin &gt;&gt; name;
      bool flag = false;  // 加入判断是否查到的标志，默认未找到职工
      for (int i = 0; i &lt; m_EmpNum; i++) &#123;
        if (this-&gt;m_EmpArray[i]-&gt;m_Name == name) &#123;
          cout &lt;&lt; &quot;查找成功，职工编号为：&quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; &quot;号职工信息如下：&quot; &lt;&lt; endl;
          flag = true;
          this-&gt;m_EmpArray[i]-&gt;showInfo();
        &#125;
      &#125;
      if (flag == false) &#123;
        cout &lt;&lt; &quot;查找失败，查无此人！&quot; &lt;&lt; endl;
      &#125;
    &#125; else &#123;
      cout &lt;&lt; &quot;输入选项有误！&quot; &lt;&lt; endl;
    &#125;
  &#125;
  system(&quot;read -n 1 -s -p 'Press any key to continue...'&quot;);
  system(&quot;clear&quot;);
&#125;
</code></pre><h2 id="133-测试查找职工"><a class="anchor" href="#133-测试查找职工">#</a> 13.3 测试查找职工</h2><p>在 main 函数分支 5 选项中，调用查找职工接口</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>  <span class="token comment">// 查找职工</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  wm<span class="token punctuation">.</span><span class="token function">findEmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>测试 1 - 按照职工编号查找 - 查找不存在职工</p><p>测试 2 - 按照职工编号查找 - 查找存在职工</p><p>测试 3 - 按照职工姓名查找 - 查找不存在职工</p><p><img data-src="/Users/lixinyi/Desktop/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%81%E4%B8%9A%E8%81%8C%E5%B7%A5%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%96%99/%E8%AE%B2%E4%B9%89/assets/1546505115610.png" alt="1546505115610"></p><p>测试 4 - 按照职工姓名查找 - 查找存在职工（如果出现重名，也一并显示，在文件中可以添加重名职工）</p><p>例如 添加两个王五的职工，然后按照姓名查找王五</p><p><img data-src="https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411081616843.png" alt=""></p><blockquote><p>同名人员信息全部显示</p></blockquote><p>至此，查找职工功能实现完毕！</p><h1 id="14-排序"><a class="anchor" href="#14-排序">#</a> 14、排序</h1><p>功能描述：按照职工编号进行排序，排序的顺序由用户指定</p><h2 id="141-排序函数声明"><a class="anchor" href="#141-排序函数声明">#</a> 14.1 排序函数声明</h2><p>在 workerManager.h 中添加成员函数 <code>void Sort_Emp();</code></p><pre><code class="language-C++">// 按照编号排序
void sortEmp();
</code></pre><h2 id="142-排序函数实现"><a class="anchor" href="#142-排序函数实现">#</a> 14.2 排序函数实现</h2><p>在 workerManager.cpp 中实现成员函数 <code>void Sort_Emp();</code></p><pre><code class="language-C++">// 按照编号排序
void WorkerManager::sortEmp() &#123;
  if (this-&gt;m_FileIsEmpty) &#123;
    cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl;
    system(&quot;read -n 1 -s -p 'Press any key to continue...'&quot;);
    system(&quot;clear&quot;);
  &#125; else &#123;
    cout &lt;&lt; &quot;请选择排序方式：&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;1、按职工号进行升序&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;2、按职工号进行降序&quot; &lt;&lt; endl;

    int select = 0;
    cin &gt;&gt; select;
    for (int i = 0; i &lt; m_EmpNum; i++) &#123;
      int minOrMax = i;  // 声明最小值或最大值下标
      for (int j = i + 1; j &lt; this-&gt;m_EmpNum; j++) &#123;
        if (select == 1) &#123;  // 升序
          if (this-&gt;m_EmpArray[minOrMax]-&gt;m_Id &gt; this-&gt;m_EmpArray[j]-&gt;m_Id) &#123;
            minOrMax = j;
          &#125;
        &#125; else &#123;  // 降序
          if (this-&gt;m_EmpArray[minOrMax]-&gt;m_Id &lt; this-&gt;m_EmpArray[j]-&gt;m_Id) &#123;
            minOrMax = j;
          &#125;
        &#125;
      &#125;
      // 判断一开始认定的最小值或最大值是不是计算的最小值或最大值，如果不是交换数据
      if (i != minOrMax) &#123;
        Worker* temp = this-&gt;m_EmpArray[i];
        this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[minOrMax];
        this-&gt;m_EmpArray[minOrMax] = temp;
      &#125;
    &#125;

    cout &lt;&lt; &quot;排序成功！排序后的结果为：&quot; &lt;&lt; endl;
    this-&gt;save();     // 排序后结果保存到文件中
    this-&gt;showEmp();  // 展示所有职工
  &#125;
&#125;
</code></pre><h2 id="143-测试排序功能"><a class="anchor" href="#143-测试排序功能">#</a> 14.3 测试排序功能</h2><p>在 main 函数分支 6 选项中，调用排序职工接口</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span>  <span class="token comment">// 排序职工</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  wm<span class="token punctuation">.</span><span class="token function">sortEmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>测试：</p><p>首先我们添加一些职工，序号是无序的</p><p>测试 - 升序排序</p><p>文件同步更新</p><p>测试 - 降序排序</p><p>文件同步更新</p><p>至此，职工按照编号排序的功能实现完毕！</p><h1 id="15-清空文件"><a class="anchor" href="#15-清空文件">#</a> 15、清空文件</h1><p>功能描述：将文件中记录数据清空</p><h2 id="151-清空函数声明"><a class="anchor" href="#151-清空函数声明">#</a> 15.1 清空函数声明</h2><p>在 workerManager.h 中添加成员函数 <code>void Clean_File();</code></p><pre><code class="language-C++">// 清空文件
void cleanFile();
</code></pre><h2 id="152-清空函数实现"><a class="anchor" href="#152-清空函数实现">#</a> 15.2 清空函数实现</h2><p>在 workerManager.cpp 中实现员函数 <code>void Clean_File();</code></p><pre><code class="language-C++">// 清空文件
void WorkerManager::cleanFile() &#123;
  cout &lt;&lt; &quot;确定清空？&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;1、确定&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot;2、返回&quot; &lt;&lt; endl;

  int select = 0;
  cin &gt;&gt; select;
  if (select == 1) &#123;
    // 清空文件
    ofstream ofs(FILENAME, ios::trunc);  // 删除文件后重新创建
    ofs.close();

    if (this-&gt;m_EmpArray != NULL) &#123;
      // 删除堆区的每个职工对象
      for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) &#123;
        delete this-&gt;m_EmpArray[i];
        this-&gt;m_EmpArray[i] = NULL;
      &#125;

      // 删除堆区数组指针
      delete[] this-&gt;m_EmpArray;
      this-&gt;m_EmpArray = NULL;
      this-&gt;m_EmpNum = 0;
      this-&gt;m_FileIsEmpty = true;
    &#125;
    cout &lt;&lt; &quot;清空成功！&quot; &lt;&lt; endl;
  &#125;

  system(&quot;read -n 1 -s -p 'Press any key to continue...'&quot;);
  system(&quot;clear&quot;);
&#125;
</code></pre><h2 id="153-测试清空文件"><a class="anchor" href="#153-测试清空文件">#</a> 15.3 测试清空文件</h2><p>在 main 函数分支 7 选项中，调用清空文件接口</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span>  <span class="token comment">// 清空文档</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  wm<span class="token punctuation">.</span><span class="token function">cleanFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>测试：确认清空文件</p><p>再次查看文件中数据，记录已为空</p><p>打开文件，里面数据已确保清空，该功能需要慎用！</p><p>随着清空文件功能实现，本案例制作完毕 ^ _ ^</p><div class="tags"><a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C++</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2024-11-08 17:06:49" itemprop="dateModified" datetime="2024-11-08T17:06:49+08:00">2024-11-08</time> </span><span id="cpp/二.实战-职工管理系统/" class="item leancloud_visitors" data-flag-title="二.实战-职工管理系统" title="Views"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">Views</span> <span class="leancloud-visitors-count"></span> <span class="text">times</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Li Xinyi WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Li Xinyi Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Li Xinyi PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Li Xinyi <i class="ic i-at"><em>@</em></i>但行好事，莫问前程</li><li class="link"><strong>Post link: </strong><a href="https://60saint.github.io/cpp/%E4%BA%8C.%E5%AE%9E%E6%88%98-%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" title="二.实战-职工管理系统">https://60saint.github.io/cpp/二.实战-职工管理系统/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/cpp/%E4%BA%8C%E3%80%81C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" itemprop="url" rel="prev" data-background-image="&#x2F;assets&#x2F;cpp.png" title="二.C++核心编程"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>二.C++核心编程</h3></a></div><div class="item right"><a href="/cpp/%E4%B8%89.C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/" itemprop="url" rel="next" data-background-image="&#x2F;assets&#x2F;cpp.png" title="三.C++提高编程"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>三.C++提高编程</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82"><span class="toc-number">1.</span> <span class="toc-text">1、管理系统需求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">2、创建项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">3、创建管理类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 创建文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 头文件实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%BA%90%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 源文件实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%8F%9C%E5%8D%95%E5%8A%9F%E8%83%BD"><span class="toc-number">4.</span> <span class="toc-text">4、菜单功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E6%B7%BB%E5%8A%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 添加成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E8%8F%9C%E5%8D%95%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 菜单功能实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E6%B5%8B%E8%AF%95%E8%8F%9C%E5%8D%95%E5%8A%9F%E8%83%BD"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 测试菜单功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">5.</span> <span class="toc-text">5、退出功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E6%8F%90%E4%BE%9B%E5%8A%9F%E8%83%BD%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 提供功能接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E5%AE%9E%E7%8E%B0%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 实现退出功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 测试功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%88%9B%E5%BB%BA%E8%81%8C%E5%B7%A5%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">6、创建职工类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E5%88%9B%E5%BB%BA%E8%81%8C%E5%B7%A5%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 创建职工抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E5%88%9B%E5%BB%BA%E6%99%AE%E9%80%9A%E5%91%98%E5%B7%A5%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 创建普通员工类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E5%88%9B%E5%BB%BA%E7%BB%8F%E7%90%86%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 创建经理类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E5%88%9B%E5%BB%BA%E8%80%81%E6%9D%BF%E7%B1%BB"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 创建老板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E6%B5%8B%E8%AF%95%E5%A4%9A%E6%80%81"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 测试多态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%B7%BB%E5%8A%A0%E8%81%8C%E5%B7%A5"><span class="toc-number">7.</span> <span class="toc-text">7、添加职工</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 功能分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 功能实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E6%B5%8B%E8%AF%95%E6%B7%BB%E5%8A%A0"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 测试添加</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%96%87%E4%BB%B6%E4%BA%A4%E4%BA%92-%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">8、文件交互 - 写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E8%AE%BE%E5%AE%9A%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 设定文件路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 成员函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 保存文件功能实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 保存文件功能测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%96%87%E4%BB%B6%E4%BA%A4%E4%BA%92-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">9.</span> <span class="toc-text">9、文件交互 - 读文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E6%96%87%E4%BB%B6%E6%9C%AA%E5%88%9B%E5%BB%BA"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 文件未创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%E4%B8%94%E6%95%B0%E6%8D%AE%E4%B8%BA%E7%A9%BA"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 文件存在且数据为空</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%E4%B8%94%E4%BF%9D%E5%AD%98%E8%81%8C%E5%B7%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 文件存在且保存职工数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#931-%E8%8E%B7%E5%8F%96%E8%AE%B0%E5%BD%95%E7%9A%84%E8%81%8C%E5%B7%A5%E4%BA%BA%E6%95%B0"><span class="toc-number">9.3.1.</span> <span class="toc-text">9.3.1 获取记录的职工人数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#932-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">9.3.2.</span> <span class="toc-text">9.3.2 初始化数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%98%BE%E7%A4%BA%E8%81%8C%E5%B7%A5"><span class="toc-number">10.</span> <span class="toc-text">10、显示职工</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E6%98%BE%E7%A4%BA%E8%81%8C%E5%B7%A5%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 显示职工函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E6%98%BE%E7%A4%BA%E8%81%8C%E5%B7%A5%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 显示职工函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103-%E6%B5%8B%E8%AF%95%E6%98%BE%E7%A4%BA%E8%81%8C%E5%B7%A5"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 测试显示职工</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%88%A0%E9%99%A4%E8%81%8C%E5%B7%A5"><span class="toc-number">11.</span> <span class="toc-text">11、删除职工</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E5%88%A0%E9%99%A4%E8%81%8C%E5%B7%A5%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">11.1.</span> <span class="toc-text">11.1 删除职工函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-%E8%81%8C%E5%B7%A5%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">11.2.</span> <span class="toc-text">11.2 职工是否存在函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113-%E8%81%8C%E5%B7%A5%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.3.</span> <span class="toc-text">11.3 职工是否存在函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E5%88%A0%E9%99%A4%E8%81%8C%E5%B7%A5%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.4.</span> <span class="toc-text">11.4 删除职工函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#115-%E6%B5%8B%E8%AF%95%E5%88%A0%E9%99%A4%E8%81%8C%E5%B7%A5"><span class="toc-number">11.5.</span> <span class="toc-text">11.5 测试删除职工</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E4%BF%AE%E6%94%B9%E8%81%8C%E5%B7%A5"><span class="toc-number">12.</span> <span class="toc-text">12、修改职工</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%BF%AE%E6%94%B9%E8%81%8C%E5%B7%A5%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">12.1.</span> <span class="toc-text">12.1 修改职工函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-%E4%BF%AE%E6%94%B9%E8%81%8C%E5%B7%A5%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.2.</span> <span class="toc-text">12.2 修改职工函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123-%E6%B5%8B%E8%AF%95%E4%BF%AE%E6%94%B9%E8%81%8C%E5%B7%A5"><span class="toc-number">12.3.</span> <span class="toc-text">12.3 测试修改职工</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E6%9F%A5%E6%89%BE%E8%81%8C%E5%B7%A5"><span class="toc-number">13.</span> <span class="toc-text">13、查找职工</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E6%9F%A5%E6%89%BE%E8%81%8C%E5%B7%A5%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 查找职工函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#132-%E6%9F%A5%E6%89%BE%E8%81%8C%E5%B7%A5%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 查找职工函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#133-%E6%B5%8B%E8%AF%95%E6%9F%A5%E6%89%BE%E8%81%8C%E5%B7%A5"><span class="toc-number">13.3.</span> <span class="toc-text">13.3 测试查找职工</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E6%8E%92%E5%BA%8F"><span class="toc-number">14.</span> <span class="toc-text">14、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">14.1.</span> <span class="toc-text">14.1 排序函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.2.</span> <span class="toc-text">14.2 排序函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#143-%E6%B5%8B%E8%AF%95%E6%8E%92%E5%BA%8F%E5%8A%9F%E8%83%BD"><span class="toc-number">14.3.</span> <span class="toc-text">14.3 测试排序功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E6%B8%85%E7%A9%BA%E6%96%87%E4%BB%B6"><span class="toc-number">15.</span> <span class="toc-text">15、清空文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#151-%E6%B8%85%E7%A9%BA%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">15.1.</span> <span class="toc-text">15.1 清空函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#152-%E6%B8%85%E7%A9%BA%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.</span> <span class="toc-text">15.2 清空函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E6%B5%8B%E8%AF%95%E6%B8%85%E7%A9%BA%E6%96%87%E4%BB%B6"><span class="toc-number">15.3.</span> <span class="toc-text">15.3 测试清空文件</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/cpp/VScode-C++%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88MAC%EF%BC%89/" rel="bookmark" title="VScode C++环境配置（MAC）">VScode C++环境配置（MAC）</a></li><li><a href="/cpp/%E4%B8%80.C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" rel="bookmark" title="一.C++基础语法入门">一.C++基础语法入门</a></li><li><a href="/cpp/%E4%BD%BF%E7%94%A8VS-Code%E8%BF%9B%E8%A1%8CC++%E5%87%BD%E6%95%B0%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/" rel="bookmark" title="使用VS Code进行C++函数分文件编写">使用VS Code进行C++函数分文件编写</a></li><li><a href="/cpp/%E4%B8%80.%E5%AE%9E%E6%88%98-%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="一.实战-通讯录管理系统">一.实战-通讯录管理系统</a></li><li><a href="/cpp/%E4%BA%8C%E3%80%81C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" rel="bookmark" title="二.C++核心编程">二.C++核心编程</a></li><li class="active"><a href="/cpp/%E4%BA%8C.%E5%AE%9E%E6%88%98-%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="二.实战-职工管理系统">二.实战-职工管理系统</a></li><li><a href="/cpp/%E4%B8%89.C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/" rel="bookmark" title="三.C++提高编程">三.C++提高编程</a></li><li><a href="/cpp/%E4%B8%89.%E5%AE%9E%E6%88%98-%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="三.实战-基于STL的演讲比赛流程管理系统">三.实战-基于STL的演讲比赛流程管理系统</a></li><li><a href="/cpp/%E7%AC%AC1%E9%98%B6%E6%AE%B5-C++%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="C++基础阶段综合案例-机房预约系统">C++基础阶段综合案例-机房预约系统</a></li><li><a href="/cpp/%E3%80%8AC++-Primer-Plus%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《C++ Primer Plus》阅读笔记">《C++ Primer Plus》阅读笔记</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Li Xinyi" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Li Xinyi</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">39</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">19</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tLzYwc0FJTlQ=" title="https:&#x2F;&#x2F;github.com&#x2F;60sAINT"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmxpeGlueWkwM0BxcS5jb20=" title="mailto:lixinyi03@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>About</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/cpp/%E4%BA%8C%E3%80%81C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/cpp/%E4%B8%89.C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/front-end/" title="In 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/front-end/JS/" title="In JavaScript">JavaScript</a></div><span><a href="/front-end/JS/JS%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1Object%E8%AF%A6%E8%A7%A3/" title="JS内置对象 Object 详解">JS内置对象 Object 详解</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/%E6%91%84%E5%BD%B1%E5%B1%95/" title="Zn1&#39;s Photographic Exhibition">Zn1's Photographic Exhibition</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cpp/" title="In C++">C++</a></div><span><a href="/cpp/%E7%AC%AC1%E9%98%B6%E6%AE%B5-C++%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/" title="C++基础阶段综合案例-机房预约系统">C++基础阶段综合案例-机房预约系统</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/data-structor/" title="In 数据结构和算法">数据结构和算法</a></div><span><a href="/data-structor/%E6%95%B0%E7%BB%84/" title="数组">数组</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cpp/" title="In C++">C++</a></div><span><a href="/cpp/%E4%BA%8C.%E5%AE%9E%E6%88%98-%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" title="二.实战-职工管理系统">二.实战-职工管理系统</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/front-end/" title="In 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/front-end/AJAX/" title="In AJAX">AJAX</a></div><span><a href="/front-end/AJAX/AJAX-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%E7%AF%87/" title="AJAX - 综合案例篇">AJAX - 综合案例篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/front-end/" title="In 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/front-end/CSS/" title="In CSS">CSS</a></div><span><a href="/front-end/CSS/CSS-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E7%AF%87/" title="CSS - 高级技巧篇">CSS - 高级技巧篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cpp/" title="In C++">C++</a></div><span><a href="/cpp/%E4%BA%8C%E3%80%81C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" title="二.C++核心编程">二.C++核心编程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/software-test/" title="In 软件测试与质量保证">软件测试与质量保证</a></div><span><a href="/software-test/postman/" title="Postman HTTP 接口测试">Postman HTTP 接口测试</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/front-end/" title="In 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/front-end/CSS/" title="In CSS">CSS</a></div><span><a href="/front-end/CSS/%E7%A7%BB%E5%8A%A8WEB%E5%BC%80%E5%8F%91%E2%80%94%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/" title="移动 WEB 开发 - 响应式布局">移动 WEB 开发 - 响应式布局</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Li Xinyi @ Zn1's Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">495k words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">7:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"cpp/二.实战-职工管理系统/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->